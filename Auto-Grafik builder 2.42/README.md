
import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import interp1d

# Введення даних
x = [160, 320, 640, 960, 1280, 1600, 3200, 6400, 9600, 12800, 16000] #значення для осі x
y = [-1.01, -1.2, -1.72, -1.93, -2.38, -3.1, -6.7, -12.3, -15.9, -20, -21.3] #значення для осі y


plt.figure(figsize=(14, 5))#розміри таблиці


f = interp1d(x, y, kind='linear') # Лінійна інтерполяція даних

# Генерування плавних значень x
x_smooth = np.array(x)
y_smooth = f(x_smooth)


plt.plot(x_smooth, y_smooth, 'bo-', markersize=4) #("x,y" по чому будється 1- це по межі х 2- по у,
Розберемо 'bo-':  "b" це колір лінії(blue),щоб змінити колір змінть початкову букву на букву того кольору, який ви хочете поставити(до прикладу r-red,g-green,b-blue,). "o"- це точки на графіку, якщо ви не хочете мати точок на графіку, то заберіть o(або заміть на той який ви хочете), "-"- це тип лінії(якщо треба лише точки, то заберіть мінус, якщо треба пунктир то напишіть "--"))


plt.xscale('log')# Масштабування осі x у логарифмічному масштабі


plt.xlabel('')# Підпис осі x

plt.ylabel('')# Підпис осі x


plt.title('Послаблення в дБ RC-ланки') # Заголовок графіку


plt.grid(True)# Відображення сітки


ax = plt.gca() # отримує поточні осі графіку за допомогою функції plt.gca(). gca - це скорочення від "get current axes" (отримати поточні осі), і цей метод дозволяє отримати посилання на поточні осі, щоб здійснити подальші налаштування.

ax.set_xscale('log')# встановлює масштабування осі x у логарифмічному масштабі за допомогою методу set_xscale('log'). Це змінює шкалу осі x на логарифмічну, що означає, що відстань між значеннями на осі x буде пропорційною до логарифма відповідних значень. Це особливо корисно, коли значення на осі x розташовані на широкому діапазоні або виражені в дуже великих або дуже малих числах. Масштабування у логарифмічному масштабі дозволяє краще візуалізувати такі дані та виявити залежності, які можуть бути приховані на лінійній шкалі.


ax.set_xticks(x) #становлює положення позначок на осі x за допомогою методу set_xticks(x). В аргументі x передається список значень, для яких будуть розміщені позначки на осі x. У даному випадку, використовується список x, який містить значення, передані на вхід в початковому коді.

ax.set_xticklabels(x)# встановлює підписи позначок на осі x за допомогою методу set_xticklabels(x). В аргументі x передається список текстових підписів для відповідних позначок на осі x. У даному випадку, використовується список x, що містить числові значення, і вони використовуються як текстові підписи для позначок на осі x.


y_ticks = np.arange(0, -22, -3) # створює список y_ticks, що містить значення для позначок на осі y. Він використовує функцію np.arange() для створення рівномірно розподілених значень в діапазоні від 0 до -22 з кроком -3.
y_tick_labels = ['{:g}'.format(y) for y in y_ticks] #створює список y_tick_labels, який містить текстові підписи для кожної позначки на осі y. Використовується генератор списку, щоб перетворити значення y_ticks в рядки, використовуючи форматування '{:g}'. Це форматування дозволяє представити числа у загальному вигляді.

plt.yticks(y_ticks, y_tick_labels)# задає позначки і підписи на осі y. Використовується функція plt.yticks() з двома аргументами: список y_ticks для визначення позицій позначок та список y_tick_labels для визначення відповідних текстових підписів для кожної позначки на осі y.


x_text = x[-1] * 1.275 # обчислює горизонтальну позицію (x-координату) тексту на осі x. Він бере останній елемент списку x (x[-1]) та множить його на 1.275, щоб змістити текст праворуч на 27.5% від цього значення. Отримується x_text, яке є горизонтальною позицією тексту на осі x.

y_text = min(y_smooth) - 1.5 #обчислює вертикальну позицію (y-координату) тексту на осі x. Він використовує функцію min() для знаходження мінімального значення у списку y_smooth (гладкі значення y) та віднімає 1.5, щоб змістити текст вниз від графіку. Отримується y_text, яке є вертикальною позицією тексту на осі x.

plt.text(x_text, y_text, 'f, Гц', ha='center', va='top') #додає текст 'f, Гц' до графіку на позиції (x_text, y_text). Параметри ha='center' та va='top' встановлюють горизонтальне і вертикальне вирівнювання тексту відповідно, тобто текст буде вирівнюватися по центру горизонтально і зверху вертикально від вказаних координат (x_text, y_text).


x_text_y = x[-11] / 1.1 #обчислює горизонтальну позицію (x-координату) тексту на осі y. Він використовує останній елемент списку x (x[-11]) та ділить його на 1.1, щоб зміщити текст вліво на 10% відносно цієї значення. В результаті отримується x_text_y, яке є горизонтальною позицією тексту на осі y.

y_text_y = max(y_smooth) + 2 #обчислює вертикальну позицію (y-координату) тексту на осі y, використовуючи функцію max() для знаходження максимального значення у списку y_smooth (гладкі значення y) та додає 2, щоб змістити текст вгору від графіку. В результаті отримується y_text_y, яке є вертикальною позицією тексту на осі y.

plt.text(x_text_y, y_text_y, 'A(f), дБ', ha='right', va='bottom') #додає текст 'A(f), дБ' до графіку на позиції (x_text_y, y_text_y). Параметри ha='right' та va='bottom' встановлюють горизонтальне і вертикальне вирівнювання тексту відповідно, тобто текст буде вирівнюватися праворуч і знизу від вказаних координат (x_text_y, y_text_y).


plt.show() # Показати графік
